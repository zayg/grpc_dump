We may need a grpc dumper to debug the GRPC request's transport behavior from the network layer.

# Goals
The initial version will be able to:

* capture the GRPC HTTP2 streams on Linux.
* analyze both the HTTP2 control frames and GRPC message in DATA frames.
produce human readable output.Â 
* support some basic filters on RPC name, src/tgt address, packet length limitation, etc..

# Solutions
|                              Solution                              |                                      Pros                                      |                                        Cons                                       |
|:------------------------------------------------------------------|:------------------------------------------------------------------------------|:---------------------------------------------------------------------------------|
| Wireshark dissectors + tcpdump                                     | 1. reduce develop work                                                         | 1. not work in realtime<br/>2. hard to parse large grpc requests<br/>3. inflexible to use |
| Integrate with the client/server by tracing http2 frames inside grpc | 1. able to get information about socket options, flow control window size. | 1. may have performance side effects<br/>2. inflexible to use<br/>3. hard to maintain     |
| Standalone (pcap)                                                 | 1. flexible to use on both server/client side.                                 | 1. hard to get the whole picture of a stream. (like flow control window size)     |

We use the third solution for its flexibility and minor side effects. The tool will depend on libpcap, libprotobuf and third party's proto files. We may take advantage from grpc chttp2 library for its http2 related definitions.

# Architecture

## WorkFlow
The workflow will consist of three parts. These three parts are connected by queues. Each part will act as an individual worker.

#### Packet Capturing

We will use libpcap to capture the TCP packets and put them into a queue. Filtering the TCP packets by target address and packet length should be enough to get the TCP payloads only contains HTTP2 frames.

#### Packet Parsing

The parsing worker will process the packets from the queue. For each packet, the worker has two responsibilities:

* Identify the events like "Find a new HTTP2 frame", "Start of a Stream", "Completion of a GRPC request", "End of a Stream", etc.. We will have different callbacks to handle each event.

* Generate HTTP2 FrameInfo. FrameInfo structure is defined in the following section.

The parser needs to understand Ethernet, IP, TCP, HTTP2 headers and some HTTP2 FRAME payload formats used by GRPC.

#### Formatted Logging

The logging worker will log the packet information get from the parser asynchronously.

## DataStructure

We demonstrate some key data structures below.

```
// Http2 stream session
// This structure will be:
// 1. collected in a hashmap with streamId as the key.
// 2. constructed/consumed by callbacks registered to the parsing worker.
struct StreamSession {
	// 128 bits stream id consist of src/tgt addr and http2
	// stream identifier.
	StreamId streamId;
	
	// Deserialization information in the first HEADER Frame
	struct {
		string callName;
		CompressionType compressType;
		MessageDeserializer msgDeserializer;
	} DeserializeMeta;
	
	// the final length of current uncompleted GRPC message
	uint32_t MsgLength;
	// uncompleted GRPC message data fragments
	vector<shared_ptr<FrameInfo>> toCompleteMsg;
	
	// some statistics
	...
}

// Single HTTP2 frame information
// This structure will be:
// 1. generated by parsing worker.
// 2. collected in a stream session if it is a data frame.
// 3. consumed by the logging worker.
struct FrameInfo {
	int64_t timestamp;
	int64_t srcAddr;
	int64_t targetAddr;
	int32_t http2StreamId;
	Http2FrameType http2Type;
	Http2Flag http2Flags;
	
	// Packet index of the packets queue
	int32_t packetIdx;
	// Offset and length of the Frame in a packet.
	int32_t offset, length;
	// The message will not be nullptr if it is the last
	// DATA Frame in a Length-Prefixed-Message.
	Message* message = nullptr;
}
```

# Details

#### How to get a complete grpc message?

Let's say the parsing worker gets a new event "Find a new HTTP2 Frame". We finish collecting all GRPC message fragments in StreamSession::toCompleteMsg, if the frame is a DATA frame and it makes up the remaining data of the current message. Then we can deserialize the GRPC message using StreamSession::DeserializeMeta.

#### How to handle error scenarios?

We only create new StreamSession when encountering the "Start of a Stream" event. If we encounter a new stream id which is not the start of the stream, we just ignore this frame.

For other scenarios, a specific error with an incomplete FrameInfo will be reported to the logging worker. At the same time, the StreamSession will be removed in the StreamSessionTable.

#### How to release the memory of processed packets and StreamSession?

To make it simple, we don't actively recycle a processed packet. Instead, we make the queue between packet capturing worker and packet parsing worker a logical ring buffer. The old processed packet will be rotated passively. We also maintain a LastPacketIndex for the queue. An incoming packet will make the LastPacketIndex increased by one. Then LastPacketIndex can be used to identify any invalid (rotated) packet index in the FrameInfo. Notice that if we get any invalid packet index while processing StreamSession::toCompleteMsg, we ignore this GRPC message and give out some kinds of WARNING. This could mean either a design issue of the recycle logic or the stream stalls.

StreamSession will be removed only when an RST_STREAM frame or an EOS flag is encountered.

